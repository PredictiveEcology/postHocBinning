---
title: "postHocBinning"
author: "Alex M. Chubaty and Isolde Lane-Shaw"
date: "15 March 2021"
output: 
  html_document: 
    keep_md: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, results = "hold")

if (FALSE) {
  install.packages(c("lwgeom", "rgdal", "rgeos", "sf", "sp", "raster", "terra"),
                 repos = "https://cran.rstudio.com")
  sf::sf_extSoftVersion() ## want GEOS 3.9.0, GDAL 3.2.1, PROJ 7.2.1
  
  remotes::install_github("PredictiveEcology/Require@development")
  remotes::install_github("PredictiveEcology/reproducible@development")
  remotes::install_github("PredictiveEcology/SpaDES.core@development")
}
```

# Overview

This module predicts expected bird densities based on land cover classification.

# Usage

```{r module_usage}
library(Require)
Require("SpaDES.core")

setPaths(modulePath = file.path(".."),
         inputPath = file.path("data"),
         outputPath = "outputs")

times <- list(start = 0, end = 1)

parameters <- list(
  postHocBinning = list()
)
modules <- list("postHocBinning")
objects <- list()
inputs <- list()
outputs <- list()

mySimOut <- simInitAndSpades(times = times, params = parameters, modules = modules, objects = objects)
```

# Parameters

Provide a summary of user-visible parameters.

```{r moduleParams, echo = FALSE, eval = TRUE}
df_params <- SpaDES.core::moduleParams("postHocBinning", "..")
knitr::kable(df_params)
```

# Events

Describe what happens for each event type.

## Plotting

Write what is plotted.

## Saving

Write what is saved.

# Data dependencies

## Input data

```{r moduleInputs, echo = FALSE, eval = TRUE}
df_inputs <- SpaDES.core::moduleInputs("postHocBinning", "..")
knitr::kable(df_inputs)
```

## Output data

Description of the module outputs.

```{r moduleOutputs, echo = FALSE, eval = TRUE}
df_outputs <- SpaDES.core::moduleOutputs("postHocBinning", "..")
knitr::kable(df_outputs)
```

# Links to other modules

Describe any anticipated linkages to other modules.

<!-- TODO: move everything below here into module code, e.g. defaults, and remove -->

# OLD -- do not use

```{r old-do-not-use, eval = FALSE}
birdsList <- c("BAWW", "OVEN") #specify the bird species
folderUrlBird <- "https://drive.google.com/drive/folders/1fCTr2P-3Bh-7Qh4W0SMJ_mT9rpsKvGEA" # give file location 

birdRasterStack <- load250mBootRasters(folderUrl = folderUrlBird,
                                       birdsList = birdsList,
                                       rastersPath = downloadFolderBird,
                                       rasterToMatch = landscapeRaster,
                                       studyArea = studyArea)

noBootsDFLocation <- "https://drive.google.com/file/d/1ldESo9gb6icRD8ZsuPgaEDSIwFjJEe4W"
noBootsDF <- drive_download(file = noBootsDFLocation, 
                            path = file.path(downloadFolderBird, "noBootsDF"),
                            type = "spreadsheet",
                            overwrite = TRUE)

getBirdDataset <- function(birdRasterStack, categoriesRaster) {
  reproducible::Require("raster")
  
  meanBirdRasters <- names(birdRasterStack) %>%
    str_detect('mean') %>%
    keep(birdRasterStack, .)
  namesMeanBirdRasters <- names(meanBirdRasters)
  
  birdDatasets <- lapply(X = meanBirdRasters, FUN = function(birdRasterLayer) {
    landBirdRasterStack <- raster::stack(categoriesRaster, birdRasterLayer)
    ## take the values from the rasters and input them to a data table calledcellValues
    cellValues <- data.table(getValues(landBirdRasterStack))
    cellValues <- setnames(cellValues, c("landCoverClass", "birdDensity"))
    
    cellValues <- na.omit(cellValues) ## remove any rows with NA
    
    ## make landCoverClass categorical rather than numerical
    cellValues$landCoverClass <- as.factor(cellValues$landCoverClass) 
    
    return(cellValues)
  })
  
  names(birdDatasets) <- meanBirdRasters

  return(birdDatasets)
}

birdDatasets <- getBirdDataset(birdRasterStack = birdRasterStack,
                               categoriesRaster = landscapeRaster)

for (i in names(birdDatasets)) {
  attr(birdDatasets[[i]], "Species") <- i ## attr(birdDatasets$OVEN, "Species")
}

birdStatsByClass <- getBirdStatsByClass(birdDatasets = birdDatasets)

for (i in names(birdStatsByClass)) {
  attr(birdStatsByClass[[i]], "Species") <- i
}

plotsBirdStatsByClass <- lapply(X = birdStatsByClass, FUN = function(singleBirdStats) {
  plotBirdStatsByClass <- ggplot(data = singleBirdStats, aes(x = landCoverClass, y = meanBirdDensity)) +
    geom_bar(stat = "identity", width = 0.7, fill = "steelblue") +
    theme_classic() +
    ggtitle("Mean Ovenbird Density by Cover Class") +
    theme(axis.text = element_text(size = 7)) +
    geom_errorbar(aes(ymin = meanBirdDensity - seBirdDensity, ymax = meanBirdDensity + seBirdDensity), width = .15)

  return(plotsBirdStatsByClass)
})

assumptionsSummary <- getAssumptionsSummary(birdStatsTables = birdStatsByClass)

kernelDensityData <- getKernelDensityData(birdDatasets = birdDatasets)

kernelDensityPlot <- getKernelDensityPlot(birdName = "Ovenbird", #sp name for title
                                          coverType = "7", #cover type name for title
                                          birdCoverDensity = kernelDensityData$OVEN$"7", #which kernel density cover type and bird species to plot
                                          meanData = birdStatsByClass$OVEN[7, meanBirdDensity] #show a red line with the mean density
)
#which sp and cover type to graph 

# plotsVarBirdDensity <- lapply(X = birdStatsByClass,
#                               FUN = function(singleBirdStats){
#                                 
# plotVarBirdDensity <- ggplot(data = singleBirdStats, aes(x =landCoverClass, y = varBirdDensity)) + geom_bar(stat="identity")
# 
# return(plotVarBirdDensity)
# 
# })
```
