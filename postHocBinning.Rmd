---
title: "Post-Hoc Binning"
author: "Isolde Lane-Shaw"
date: "6/11/2020"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

```

# Introduction

In the following code chunks, rasters showing Canadian land cover classes and predicted densities of a given bird species across Canada will be inputted. The data will be extracted and used, for a given study area, to predict expected densities of the bird for each of the land cover classes. 
# Load essential packages

We start by loading all the packages we will use.

```{r packages}

#list packages to load
library("SpaDES")
library("raster")
library("sf")
library("rgdal")
library("googledrive")
library("data.table")
library("plotrix") 
library("ggplot2")
library("ggpubr")
library("LandR")
library("diptest")
library("nortest")
library("dplyr")

```


# Get Landscape Data

Here the LLC2005 raster layer of Canada is read in using the LandR prepInputs function. It will be used as the rasterToMatch layer for other spatial layers to reproject to match, and will also provide land cover classification data.

```{r LCC2005}

rasterToMatch <- LandR::prepInputsLCC() 

```

The study area that we are interested in is then downloaded and read in using the prepInputs function. In this example we are using an area of North-East British Columbia. 

```{r studyArea, echo=FALSE}

nameAreaShapefile <- "BCR6_BC.shp" #specify file name
folderUrlArea <- "https://drive.google.com/file/d/1SjUKXOcNqDUkRxRTjwgLlLFjb5LRzbHy/view?usp=sharing" #give file location 
archiveArea <- "BCR6_BC.zip" #give archive name
downloadFolderArea <- paste0(getwd(),"/studyArea") #say where to download to

studyArea <- prepInputs(targetFile = nameAreaShapefile, 
                            url = folderUrlArea,
                            archive = archiveArea, 
                            alsoExtract = "similar", #Extract other files with similar names
                            destinationPath = downloadFolderArea, #save the file to a folder in the working directory called studyArea
                            fun = "raster::shapefile", #use the function shapefile
                            rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                            overwrite = TRUE)

```

The landscapeRaster is then created by masking and cropping the LCC2005 rasterToMatch to the size of the given studyArea. 

```{r cropAndMask}

landscapeRaster <- raster::crop(rasterToMatch,studyArea) #create landscapeRaster by cropping rasterToMatch to studyArea
landscapeRaster <- mask(landscapeRaster, studyArea) #mask landscapeRaster to studyArea
plot(landscapeRaster) #visually check landscapeRaster 

```



# Get Bird Density Data



```{r getBirdDensityRaster}

# A single raster of predicted bird densities is downloaded and loaded via prepInputs, as with the studyArea.

# nameBirdRaster <- "mosaic-OVEN-run3.tif" #specify file name
# folderUrlBird <- "https://drive.google.com/file/d/1xGhYgy71-8gjjMkgBg6F2kyp4hI3Y4rl/view?usp=sharing" #give file location 
# archiveBird <- "birdDensityRasters.zip" #archive name
# downloadFolderBird <- paste0(getwd(),"/birdRasterFiles") #say where to download to
# 
# birdRaster <- prepInputs(targetFile = nameBirdRaster, 
#                             url = folderUrlBird, 
#                             archive = archiveBird, 
#                             alsoExtract = "similar",
#                             destinationPath = downloadFolderBird,
#                             fun = "raster::raster", # the function raster is used to input the file
#                             rasterToMatch = landscapeRaster, # give the landscapRaster to be reprojected and cropped to
#                             studyArea = studyArea, #give the studyArea for the raster to be masked to
#                             overwrite = TRUE)
# 
# plot(birdRaster) #visually check birdRaster

```

Multiple rasters of predicted bird density are downloaded, postProcessed, loaded and output as a raster stack. To do this we first define a function to download rasters for the chosen bird species, and output a list of the rasters that have been downloaded. 

```{r functionDownloadBirdDensityRasters}
#load/download necessary packages
  reproducible::Require("googledrive")
  reproducible::Require("raster")
  
downloadBirdDensityRasters <- function(folderUrl, 
                                       birdsList, 
                                       rastersPath){
#drive_ls function is used to list all the files it finds using the folder url with the given pattern
   filesToDownload <- googledrive::drive_ls( path = as_id(folderUrl), pattern = "mosaic-")
 #grepl function searches for all items in the filesToDownload that are on birdList & stores their names in rastersforBirdList 
  rastersForBirdList <- filesToDownload$name[grepl(pattern = paste(birdsList, collapse = "|"), x = filesToDownload$name)]
  
#for each item in turn from rastersForBirdlist the following function is applied: 
  downloadedRasters <- lapply(X = rastersForBirdList, FUN = function(rasterFile){
#if the item in rastersForBirdList is not already present at rastersPath, googledrive package downloads it    
        if (!file.exists(file.path(rastersPath, rasterFile))){
      googledrive::drive_download(file = as_id(filesToDownload[filesToDownload$name %in% rasterFile, ]$id), #rasterFile,
                                  path = file.path(rastersPath, rasterFile), overwrite = TRUE)
    }
#otherwise, if it is already present and downloaded, just get the name of the item
    return(raster(file.path(rastersPath, rasterFile), verbose = TRUE))
  })

#get the species codes as names for the downloadedRasters object, rather than using the whole filepath
   X <- lapply(rastersForBirdList, substr, 8, 11) #works for strings of the form mosaic-XXXX-run3
   names(downloadedRasters) <- X
#the downloadBirdDensityRasters function returns/loads the downloaded rasters
 return(downloadedRasters)
}

```

The download bird function is called by a second defined function, which postprocesses (reprojected, cropped and masked according to the given rasterToMatch and studyArea) and loads the rasters in a raster stack.   

```{r functionLoadBirdDensityRasters}

loadBirdDensityRasters <- function(birdsList,
                                   folderUrl,
                                   rastersPath,
                                   rasterToMatch,
                                   studyArea){
  reproducible::Require("raster")
#check that there is a folder at the given rastersPath. if not, create it. 
  rastersPath <- checkPath(file.path(rastersPath), create = TRUE) 
#download the rasters on the birdList. Return List of downloaded files.
  downloadedRasters <- downloadBirdDensityRasters(folderUrl = folderUrl,  
                                                  birdsList = birdsList, 
                                                  rastersPath = rastersPath)
  
#lapply applys the custom function to each raster in turn
  postprocessedRasters <- lapply(X = downloadedRasters, FUN = function(RasterLayer){
#the function postProcesses the layer, cropping and masking it to a given study area and rasterToMatch, and saving it to a given destination path
    proRaster <- postProcess(RasterLayer, 
                             studyArea = studyArea, 
                             rasterToMatch = rasterToMatch, 
                             destinationPath = rastersPath)
#each layer is returned into the object proRaster
    return(proRaster)
  })
  
#birdDensityRasterStack are made into a raster stack
  birdDensityRasterStack <- raster::stack(postprocessedRasters)
#Finally the whole function returns the birdDensityRasterStack
    return(birdDensityRasterStack)
}
  
  
```

Here, we define which bird species we want, where to download the bird density rasters from, and where to save them. It then calls the loadBirdDensityRaster function. 

```{r callBirdRasterLoadFunction}

birdsList <- c("CAWA","OVEN", "ALFL", "AMCR", "AMGO", "AMPI", "AMRE", "AMRO", "ATSP", "ATTW", "BANS", "BAOR", "BARS", "BAWW", "BBMA", "BBWA", "BBWO", "BCCH", "BEKI", "BGGN", "BHCO", "BHVI", "BLBW", "BLJA", "BLPW", "BOBO", "BOCH", "BOWA", "BRBL", "BRCR", "BRTH", "BTBW", "BTNW", "BWWA",  "CCSP", "CEDW", "CHSP", "CLSW", "CMWA", "COGR", "CONW", "CORA", "COYE", "CSWA", "DEJU", "DOWO", "DUFL", "DUNL", "EABL", "EAKI", "EAPH", "EATO", "EAWP", "EUST", "EVGR", "FISP", "FOSP", "GCFL", "GCKI", "GCSP", "GCTH", "GRAJ", "GRCA", "GRSP", "GRYE", "GWWA", "HAFL", "HAWO", "HETH", "HOLA", "HOSP", "HOWR", "INBU", "KILL", "LALO", "LCSP", "LEFL", "LEYE", "LISP", "MAWA", "MOBL", "MODO", "MOWA", "NAWA", "NESP", "NOCA", "NOFL", "NOPA", "NOWA", "OCWA", "OSFL", "PAWA", "PHVI", "PIGR", "PISI", "PIWA", "PIWO", "PUFI", "RBGR", "RBNU", "RBWO", "RCKI", "RECR", "REVI", "RHWO", "ROPI", "RTHU", "RUBL", "RUGR", "RWBL", "SAVS", "SCTA", "SEWR", "SOGR", "SOSA", "SOSP", "SPGR", "SPSA", "SWSP", "SWTH", "TEWA", "TOSO", "TOWA", "TRES", "UPSA", "VATH", "VEER", "VESP", "WAVI", "WBNU", "WCSP", "WETA", "WEWP", "WIPT", "WISN", "WITU", "WIWA", "WIWR", "WOTH", "WTSP", "WWCR", "YBCU", "YBFL", "YBSA", "YEWA", "YHBL", "YRWA") #specify the bird species 
downloadFolderBird <- paste0(getwd(),"/birdRasterFiles") #say where to download to
folderUrlBird <- "https://drive.google.com/drive/folders/11HdfTqNhHmzJ8Qk0Pk0NfiLKwyRkrltS?usp=sharing" # give file location 

birdDensityRasterStack <- loadBirdDensityRasters(folderUrl = folderUrlBird,
                                                 birdsList = birdsList,
                                                 rastersPath = downloadFolderBird,
                                                 rasterToMatch = landscapeRaster,
                                                 studyArea = studyArea)

```







# Download/load bootstrapped bird rasters

```{r functionDownloadBootstrappedBirdDensityRasters}
#load/download necessary packages
  reproducible::Require("googledrive")
  reproducible::Require("raster")

downloadBootstrappedBirdDensityRasters <- function(folderUrl,
                                       birdsList,
                                       rastersPath,
                                       BCR){
#drive_ls function is used to list all the files it finds using the folder url with the given pattern
  browser()
   filesToDownload <- googledrive::drive_find(pattern = "BCR_10",
                                              n_max = 5000)
 #grepl function searches for all items in the filesToDownload that are on birdList & stores their names in rastersforBirdList
  rastersForBirdList <- filesToDownload$name[grepl(pattern = paste(birdsList, collapse = "|"), x = filesToDownload$name)]

#for each item in turn from rastersForBirdlist the following function is applied:
  downloadedRasters <- lapply(X = rastersForBirdList, FUN = function(rasterFile){
#if the item in rastersForBirdList is not already present at rastersPath, googledrive package downloads it
        if (!file.exists(file.path(rastersPath, rasterFile))){
      googledrive::drive_download(file = as_id(filesToDownload[filesToDownload$name %in% rasterFile, ]$id), #rasterFile,
                                  path = file.path(rastersPath, rasterFile), overwrite = TRUE)
    }
#otherwise, if it is already present and downloaded, just get the name of the item
    return(raster(file.path(rastersPath, rasterFile), verbose = TRUE))
  })

#the downloadBirdDensityRasters function returns/loads the downloaded rasters
 return(downloadedRasters)
}

```

  

```{r functionLoadBootstrappedBirdDensityRasters}

loadBirdDensityRasters <- function(birdsList,
                                   folderUrl,
                                   rastersPath,
                                   rasterToMatch,
                                   studyArea){
  reproducible::Require("raster")
#check that there is a folder at the given rastersPath. if not, create it.
  rastersPath <- checkPath(file.path(rastersPath), create = TRUE)
#download the rasters on the birdList. Return List of downloaded files.
  downloadedRasters <- downloadBirdDensityRasters(folderUrl = folderUrl,
                                                  birdsList = birdsList,
                                                  rastersPath = rastersPath)

#lapply applys the custom function to each raster in turn
  postprocessedRasters <- lapply(X = downloadedRasters, FUN = function(RasterLayer){
#the function postProcesses the layer, cropping and masking it to a given study area and rasterToMatch, and saving it to a given destination path
    proRaster <- postProcess(RasterLayer,
                             studyArea = studyArea,
                             rasterToMatch = rasterToMatch,
                             destinationPath = rastersPath)
#each layer is returned into the object proRaster
    return(proRaster)
  })

#birdDensityRasterStack are made into a raster stack
  birdDensityRasterStack <- raster::stack(postprocessedRasters)
#Finally the whole function returns the birdDensityRasterStack
    return(birdDensityRasterStack)
}


```



```{r callBootstrappedBirdRasterLoadFunction}

birdsList <- c("AMCR", "ALFL") #specify the bird species
downloadFolderBird <- paste0(getwd(),"/bootstrappedBirdRasterFiles") #say where to download to
folderUrlBird <- "https://drive.google.com/drive/folders/16QuPHhREahj1q6InBZIKVLHf2E_s6Atv?usp=sharing" # give file location
BCR <- 10

downloadedBootstrappedBirdRasters <- downloadBootstrappedBirdDensityRasters(folderUrl = folderUrlBird,
                                                   birdsList = birdsList,
                                                   rastersPath = downloadFolderBird,
                                                   BCR = BCR)
                                                   #rasterToMatch = landscapeRaster,
                                                   #studyArea = studyArea)

# birdDensityRasterStack <- loadBirdDensityRasters(folderUrl = folderUrlBird,
#                                                  birdsList = birdsList,
#                                                  rastersPath = downloadFolderBird,
#                                                  rasterToMatch = landscapeRaster,
#                                                  studyArea = studyArea)

```



# Create data table of bird density by landscape

A data table is created, containing the number of cells of each land cover class that are found in the landscapeRaster, and the mean bird density for each land cover class, alongside the variance, and the standard error of this mean density. 

The first step is to gather the values from the rasters and create a clean dataset. We then  calculate, for each cover class, the number of cells in this class, the mean bird density, and the variance and standard error for bird density. 

## Get bird dataset

```{r functionGetBirdDataset}

getBirdDataset <- function(birdRasterStack,
                           categoriesRaster){
  
  reproducible::Require("raster")
  
  namesBirdsLoaded <- names(birdRasterStack)
  birdRasterList <- as.list(birdRasterStack) 
  
  birdDatasets <- lapply(X = birdRasterList,
                        FUN = function(birdRasterLayer){

                               landBirdRasterStack <- raster::stack(categoriesRaster, birdRasterLayer)
                                # take the values from the rasters and input them to a data table calledcellValues
                                cellValues <- data.table(getValues(landBirdRasterStack)) 
                                cellValues <- setnames(cellValues, c("landCoverClass", "birdDensity"))
                                # remove any rows with NA
                                cellValues <- na.omit(cellValues) 
                                # make landCoverClass categorical rather than numerical
                                cellValues$landCoverClass <- as.factor(cellValues$landCoverClass) 

        return(cellValues)
       })
  
  names(birdDatasets) <- namesBirdsLoaded
  
    return(birdDatasets)
}
```

```{r getBirdDataset}


birdDatasets <- getBirdDataset(birdRasterStack = birdDensityRasterStack,
                               categoriesRaster = landscapeRaster)

for(i in names(birdDatasets)){attr(birdDatasets[[i]],"Species")<- i} #attr(birdDatasets$OVEN,"Species")

```


## Get bird densities by cover class

```{r functionGetBirdStatsByClass}

getBirdStatsByClass <- function(birdDatasets){
  
  namesBirdsAnalysed <- names(birdDatasets) 
  #base::attr()
  birdStatsByClass <- lapply(X = birdDatasets,
                             FUN = function(singleBirdDataset){
  print(attr(singleBirdDataset,"Species")) 
        flush.console()
                               birdStats <- singleBirdDataset[order(landCoverClass) # order the rows by the land cover class
                                            ][,list(classCount = .N, # get the number of cells each cover class
                                              #meanBirdDensity = mean(birdDensity), # get the mean bird density for each cover class
                                              meanBirdDensity = mean(birdDensity), #try log of mean bird density
                                              varBirdDensity = var(birdDensity), # get the variance for bird density for each cover class
                                              seBirdDensity = std.error(birdDensity), # get the standard error for bird density for each cover class
                                              normality =tryCatch(ad.test(birdDensity)$p.value,error = function(cond){return(NaN)}), #ifelse(mean(birdDensity) > 0, tryCatch(ad.test(birdDensity)$p.value,error = function(cond){return(NA)}), NA),
                                                
                                              
                                              unimodality =   dip.test(birdDensity)$p.value),                                              
                                             
                                   by = landCoverClass, 
                                   ]
                                           
              return(birdStats)
            })
  
  names(birdStatsByClass) <- namesBirdsAnalysed
  
        return(birdStatsByClass)
}

```

```{r getBirdStatsbyClass}

birdStatsByClass <- getBirdStatsByClass(birdDatasets = birdDatasets)

for(i in names(birdStatsByClass)){attr(birdStatsByClass[[i]],"Species")<- i}

```


### Are the normality and unimodality tests passed?

```{r functionGetAssumptionsSummary}

getAssumptionsSummary <- function(birdStatsTables){

  namesBirdsAnalysed <- names(birdStatsTables) 

   byBirdAssumptions <- lapply(birdStatsTables,
                             FUN = function(x){
   
        print(attr(x,"Species")) 
        flush.console()     
      #Normality Proportion 
     
        norm <- length(x$normality[!is.na(x$normality)])
          if (norm == "0") {
          propNormal <- NA
        } else {
          noNormal <- sum(!(x$normality[!is.na(x$normality)]) > 0.05)
          totalClassesNorm <- length(x$normality[!is.na(x$normality)]) 
          propNormal <- noNormal/totalClassesNorm
}
       
      
      #unimodal proportion                        
      noUnimodal <- sum(!(x$unimodality > 0.05))
      totalClassesUni <- length(x$unimodality)
      propUnimodal <- noUnimodal/totalClassesUni

      #assumptions <- data.table(propUnimodal) 
      assumptions <- data.table(propNormal, propUnimodal)        
            return(assumptions) 
       
                             })
   
                    names(byBirdAssumptions) <- namesBirdsAnalysed
  
               numberOfSpecies <- length(byBirdAssumptions) 
               
               birdAssumpTab <- rbindlist(byBirdAssumptions, use.names = TRUE, idcol = "birdSp")
               
               #proportion of species where > 50% cover types are normal
               numberOfSpeciesNorm <- length(birdAssumpTab$propNormal[!is.na(birdAssumpTab$propNormal)]) 
               numberSpNormal <-  sum(!(birdAssumpTab$propNormal[!is.na(birdAssumpTab$propNormal)] < 0.5))
               propSpNormal <- numberSpNormal/numberOfSpeciesNorm
              
               #proportion of species where > 50% cover types are unimodal  
               numberSpUnimodal <- sum(!(birdAssumpTab$propUnimodal < 0.5))
               propSpUnimodal <- numberSpUnimodal/numberOfSpecies
               
               birdAssumptions <- data.table(propSpNormal, propSpUnimodal)
                               
                return(birdAssumptions)
                    
                               }
  
```

```{r getAssumptionsSummary}

assumptionsSummary <- getAssumptionsSummary(birdStatsTables= birdStatsByClass)

```



### Plot mean bird density by land cover class with SE bars

```{r plotbirdStatsbyClass}


plotsBirdStatsByClass <- lapply(X = birdStatsByClass,
                             FUN = function(singleBirdStats){
                            
    plotBirdStatsByClass <- ggplot(data = singleBirdStats, aes(x =landCoverClass, y = meanBirdDensity)) +   geom_bar(stat="identity", width=0.7, fill="steelblue") + theme_classic() + ggtitle("Mean Ovenbird Density by Cover Class") + theme(axis.text=element_text(size=7)) +
geom_errorbar(aes(ymin=meanBirdDensity-seBirdDensity, ymax=meanBirdDensity+seBirdDensity), width=.15) 
 
return(plotsBirdStatsByClass)
 
                             })

```

#Examine the data using a kernel density plot

### Get Kernel Density Data and Store in Lists

```{r getKernelDensityDataFunction}

getKernelDensityData <- function(birdDatasets){
  
  namesBirdsAnalysed <- names(birdDatasets) 
  
  birdKernelDensities <- lapply(X = birdDatasets,
                             FUN = function(singleBirdDataset){
                           
      namesClasses <- levels(singleBirdDataset$landCoverClass) 
     
      classKernelDensities <- lapply(X = namesClasses,
                              FUN = function(coverType){
          
            dataForDensity <- singleBirdDataset[landCoverClass == coverType]
            singleClassDensity <- density(dataForDensity[,birdDensity])

            return(singleClassDensity)
                              })
            
      names(classKernelDensities) <- namesClasses      
      return(classKernelDensities)
                    })

  names(birdKernelDensities) <- namesBirdsAnalysed
  return(birdKernelDensities)
}

```

```{r getKernelDensityData}

kernelDensityData <- getKernelDensityData(birdDatasets = birdDatasets)

```


## Plot a Particular Kernel Density Data

```{r getKernelDensityPlotFunction}

getKernelDensityPlot <- function(birdCoverDensity,
                                 birdName,
                                 coverType,
                                 meanData){
densityPlot <- plot(birdCoverDensity,
     main = paste0("Kernel Density for ", paste0(birdName), " in CC", coverType),
     xlab = "Predicted Bird Density",
     ylab = "Density of predictions") +     
  abline(v = meanData, col = "red") 

    return(densityPlot)
                        }

```

```{r getKernelDensityPlot}

kernelDensityPlot <- getKernelDensityPlot(birdName = "Ovenbird", #sp name for title
                                          coverType = "7", #cover type name for title
                                          birdCoverDensity = kernelDensityData$OVEN$"7", #which kernel density cover type and bird species to plot
                                          meanData = birdStatsByClass$OVEN[7,meanBirdDensity] #show a red line with the mean density
                                          )
#which sp and cover type to graph 

```

```{r plotVarBirdDensity}
# 
# plotsVarBirdDensity <- lapply(X = birdStatsByClass,
#                               FUN = function(singleBirdStats){
#                                 
# plotVarBirdDensity <- ggplot(data = singleBirdStats, aes(x =landCoverClass, y = varBirdDensity)) + geom_bar(stat="identity")
# 
# return(plotVarBirdDensity)
# 
#                              })

```


# Input kNN Age Raster

```{r getBirdDensityRaster}

# nameAgeRaster <- "NFI_MODIS250m_2011_kNN_Structure_Stand_Age_v1.tif" #specify file name
# folderUrlAge <- "https://drive.google.com/file/d/1dBnNNUJ-esognueDN5zPsrQo3Plpi9on/view?usp=sharing" #give file location 
# archiveAge <- "kNN_rasters.zip" #archive name
# downloadFolderAge <- paste0(getwd(),"/ageRasterFiles") #say where to download to
# 
# ageRaster <- prepInputs(targetFile = nameAgeRaster, 
#                             url = folderUrlAge, 
#                             archive = archiveAge, 
#                             alsoExtract = "similar",
#                             destinationPath = downloadFolderAge,
#                             fun = "raster::raster", # the function raster is used to input the file
#                             rasterToMatch = landscapeRaster, # give the landscapRaster to be reprojected and cropped to
#                             studyArea = studyArea, #give the studyArea for the raster to be masked to
#                             overwrite = TRUE)
# 
# plot(ageRaster) #visually check ageRaster

```

# Get values of age raster

```{r getAgeRasterValues}
# 
# 
# ageRasterStack <- stack(landscapeRaster, birdRaster, ageRaster) # stack the three rasters
# ageValues <- as.data.frame(getValues(ageRaster, landscapeRaster,)) # take the values from the two rasters and input them to a dataframe called cellValues
# #colnames(ageStackValues) <- c("landCoverClass", "birdDensity", "age") # give the columns names 
# ageValues <- na.omit(ageValues) # remove any NAs
# #ageStackValues$LCC2005_V1_4a <- as.factor(ageStackValues$LCC2005_V1_4a) # make landCoverClass categorical rather than numerical
# tmp <- as.data.frame(ageRasterStack)                          
```
