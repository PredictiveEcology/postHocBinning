---
title: "Post-Hoc Binning"
author: "Isolde Lane-Shaw"
date: "6/11/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In the following code chunks, rasters showing Canadian land cover classes and predicted densities of a given bird species across Canada will be inputted.
The data will be extracted and used, for a given study area, to predict expected densities of the bird for each of the land cover classes.

# Load essential packages and setup directories

```{r packages}
library(Require)

#list packages to load
Require("data.table")
Require("rgdal")
Require("sf")
Require("raster")
Require("SpaDES.core") ## TODO: not used
Require("LandR")
Require("googledrive")
Require("plotrix") 
Require("ggplot2")
Require("ggpubr")
Require("diptest")
Require("nortest")
Require("gbm")
Require("dplyr")
Require("tidyverse")
Require("reshape2")

inputsDir <- checkPath("inputs", create = TRUE)
outputsDir <- checkPath("outputs", create = TRUE)

downloadFolderArea <- checkPath(file.path(inputsDir, "studyArea"), create = TRUE)
downloadFolderBird <- checkPath(file.path(inputsDir, "birdRasterFiles"), create = TRUE)
downloadFolderForestClass <- checkPath(file.path(inputsDir, "forestClassRasters"), create = TRUE)
```


#Get rasterToMatch

Here the LLC2005 raster layer of Canada is read in using the `LandR::prepInputsLCC` function.
It will be used as the `rasterToMatch` layer for other spatial layers to reproject to, and will also provide land cover classification data.

```{r LCC2005}
rasterToMatch <- LandR::prepInputsLCC(destinationPath = inputsDir) 
```


#Define Study Area

The study area that we are interested in is then downloaded and read in using the prepInputs function. In this example we are using an area of North-East British Columbia. 

```{r studyArea, echo=FALSE}
nameAreaShapefile <- "BCR6_BC.shp" #specify file name
folderUrlArea <- "https://drive.google.com/file/d/1SjUKXOcNqDUkRxRTjwgLlLFjb5LRzbHy"
archiveArea <- "BCR6_BC.zip" #give archive name

studyArea <- prepInputs(targetFile = nameAreaShapefile, 
                        url = folderUrlArea,
                        archive = archiveArea, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderArea, #save the file to a folder in the working directory called studyArea
                        fun = "raster::shapefile", #use the function shapefile
                        targetCRS = crs(rasterToMatch),
                        #rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        overwrite = TRUE,
                        verbose = TRUE)
# studyArea <- spTransform(studyArea, crs(rasterToMatch))

rasterToMatch <- raster::crop(rasterToMatch, studyArea) #create landscapeRaster by cropping rasterToMatch to studyArea
rasterToMatch <- raster::mask(rasterToMatch, studyArea) #mask landscapeRaster to studyArea
#landscapeRasters <- unstack(landscapeRastersStack)

```


# Get Landscape Data

Here we download and load the rasters giving data on the landscape. 

First we download a raster that gives the forest cover types, in forested areas.

```{r getForClassRaster}

nameForClassRaster <- "VegTypeABBC.tif" #specify file name
folderUrlForClass <- "https://drive.google.com/file/d/1cfrb-RhiwMD4XlS_yzRSQYPVh8ffwC0L/view?usp=sharing"
archiveForClass <- "vegTypeABBC.zip" #give archive name

forClassRaster <- prepInputs(targetFile = nameForClassRaster, 
                        url = folderUrlForClass,
                        archive = archiveForClass, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        useCache = getOption("reproducible.useCache", FALSE),
                        overwrite = TRUE,
                        verbose = TRUE)

names(forClassRaster) <- c("forClassRaster")

forClassRaster[forClassRaster == 0] <- NA

# #rename the categories found in the rasters
# namesValues <- as.factor(unique(forClassRaster))
# newVals <- unlist(lapply(X = namesValues, FUN = function(x) {
# newVal <-  as.factor(paste0("FR", x))
#     return(newVal)
#   }))
# reclassVector <- c(rbind(namesValues, newVals))
# reclassMatrix <- matrix(reclassVector,
#                               ncol=2, byrow = TRUE)
# forClassRaster <- reclassify(forClassRaster,
#                      reclassMatrix)

plot(forClassRaster) #visually check forClassRaster

```

Then we input a raster that gives cover types in non forested areas

```{r getNonForRaster}

nameNonForRaster <- "LCC2005_V1_4a.tif" #specify file name
folderUrlNonFor <- "https://drive.google.com/file/d/1E3iQRfaSPx0-b2GTgbLZqjo2Nhom39EK/view?usp=sharing"
archiveNonFor <- "LCC2005_V1_4a.zip" #give archive name

nonForRaster <- prepInputs(targetFile = nameNonForRaster, 
                        url = folderUrlNonFor,
                        archive = archiveNonFor, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        useCache = getOption("reproducible.useCache", FALSE),
                        overwrite = TRUE,
                        verbose = TRUE)

names(nonForRaster) <- c("nonForRaster")

nonForRaster <- overlay(x = nonForRaster, y = forClassRaster, fun = function(x, y) {
                         x[!is.na(y[])] <- NA
                          return(x)
                            })

#rename the categories found in the rasters
# namesValues <- unique(nonForRaster)
# newVals <- unlist(lapply(X = namesValues, FUN = function(x) {
# newVal <-  as.factor(paste0("NF", x))    
#     return(newVal)
#   }))
# reclassVector <- c(rbind(namesValues, newVals))
# reclassMatrix <- matrix(reclassVector, 
#                               ncol=2, byrow = TRUE)
# nonForRaster <- reclassify(nonForRaster,
#                      reclassMatrix)

plot(nonForRaster) #visually check nonForRaster

```

We then combine the nonForRaster and the forClassRaster so that we have a single raster giving the cover types (both forested and non-forested) over the study region. 

```{r createLandscapeRaster}

landscapeRaster <- cover(x = forClassRaster,
                         y = nonForRaster,
                         filename = "landscapeRaster",
                         overwrite = TRUE )

names(landscapeRaster) <- c("landscapeRaster")

plot(landscapeRaster) #visually check nonForRaster

```

```{r createFNFRaster}

#create a raster that gives if an area is forest or not (0 for non-forest, 1 for forest)
#This will allow me to have a value in the birdDataset that says if a cell was forested or not

#make forest 1
valsFR <- unique(forClassRaster)
newValFR <-  as.factor(rep("1", length(valsFR)))
newValsFR <- cbind(valsFR, newValFR)
reclassMatrixFR <- matrix(newValsFR, 
                              ncol=2, byrow = FALSE)
rasterFR <- reclassify(forClassRaster,
                     reclassMatrixFR)

#make the rest 0 
replaceNA <- function(x, na.rm, ...){ 
  if(is.na(x[1]))
    return(0)
  else
    return(x)
} 

FNFRaster <- calc(rasterFR, fun = replaceNA)
#mask back down to size again
FNFRaster <- raster::mask(FNFRaster,rasterToMatch)

names(FNFRaster) <- c("FNFRaster")

plot(FNFRaster) #visually check FNFRaster

```

Finally, we input a raster that gives the ages of the forested areas in age classes. 

```{r getForAgeRaster}

nameForAgeRaster <- "ageRas.tif" #specify file name
folderUrlAge <- "https://drive.google.com/file/d/1Ih4YLfIYX6nQcotdd41j4yRtZKRQxYo7/view?usp=sharing"
archiveAge <- "ageRaster.zip" #give archive name

forAgeRaster <- prepInputs(targetFile = nameForAgeRaster, 
                        url = folderUrlAge,
                        archive = archiveAge, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        overwrite = TRUE,
                        verbose = TRUE)

names(forAgeRaster) <- c("forAgeRaster")

plot(forAgeRaster) #visually check ageRaster
```

##Get KNN age raster to fill in non forested ages

```{r getkNNAgeRaster}

namekNNAgeRaster <- "NFI_MODIS250m_2011_kNN_Structure_Stand_Age_v1.tif" #specify file name
folderUrlkNNAge <- "https://drive.google.com/file/d/1Ih4YLfIYX6nQcotdd41j4yRtZKRQxYo7/view?usp=sharing"
archivekNNAge <- "ageRaster.zip" #give archive name

kNNAgeRaster <- prepInputs(targetFile = namekNNAgeRaster, 
                        url = folderUrlkNNAge,
                        archive = archivekNNAge, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        overwrite = TRUE,
                        verbose = TRUE)

names(kNNAgeRaster) <- c("kNNAgeRaster")

plot(kNNAgeRaster) #visually check kNNAgeRaster
```

```{r createAgeRaster}

ageRaster <- cover(x = forAgeRaster,
                         y = kNNAgeRaster,
                         filename = "ageRaster",
                         overwrite = TRUE )

names(ageRaster) <- c("ageRaster")

plot(ageRaster) #visually check nonForRaster

```

# Get Bird Density Data

## Download/load 250m bootstrapped bird rasters for mean and variance, and the DF giving numbers of bootstrap replicates the rasters were derived from.

Multiple rasters of predicted bird density are downloaded, postProcessed, loaded and output as a raster stack, alongside rasters giving the variance between bootstraps at each pixel. 

To do this we first define a function to download rasters for the chosen bird species, and output a list of the rasters that have been downloaded. 

```{r functionDownload250mBootRasters}
download250mBootRasters <-
  function(folderUrl, birdsList, rastersPath) {
    ## drive_ls function is used to list all the files it finds using the folder url with the given pattern
    filesToDownload <-
      googledrive::drive_ls(path = as_id(folderUrl)) #note: has to be changed if filenaming system changes
    ## grepl function searches for all items in the filesToDownload that are on birdList & stores their names in rastersforBirdList
    rastersForBirdList <-
      filesToDownload$name[grepl(pattern = paste(birdsList, collapse = "|"),
                                 x = filesToDownload$name)]
    
    ## for each item in turn from rastersForBirdlist the following function is applied:
    downloadedRasters <-
      lapply(
        X = rastersForBirdList,
        FUN = function(rasterFile) {
          ## if the item in rastersForBirdList is not already present at rastersPath, googledrive package downloads it
          if (!file.exists(file.path(rastersPath, rasterFile))) {
            googledrive::drive_download(
              file = as_id(filesToDownload[filesToDownload$name %in% rasterFile,]$id),
              #rasterFile,
              path = file.path(rastersPath, rasterFile),
              overwrite = TRUE
            )
          }
          
          ## otherwise, if it is already present and downloaded, just get the name of the item
          return(raster(file.path(rastersPath, rasterFile), verbose = TRUE))
        }
      )
    
    #get the species codes as names for the downloadedRasters object, rather than using the whole filepath
    X <-
      lapply(rastersForBirdList, substr, 1, 8) #works for strings of the form "varsXXXX" or "meanXXXX"
    names(downloadedRasters) <- X
    #the downloadBirdDensityRasters function returns/loads the downloaded rasters
    return(downloadedRasters)
  }
```


The download bird function is called by a second defined function, which postprocesses (reprojects, crops and masks according to the given rasterToMatch and studyArea) and loads the rasters in a raster stack.   


```{r functionLoad250mBootRasters}
load250mBootRasters <- function(birdsList,
                                folderUrl,
                                rastersPath,
                                rasterToMatch,
                                studyArea) {
  reproducible::Require("raster")
  ## check that there is a folder at the given rastersPath. if not, create it. 
  rastersPath <- checkPath(file.path(rastersPath), create = TRUE) 
  ## download the rasters on the birdList. Return List of downloaded files.
  downloadedRasters <- download250mBootRasters(folderUrl = folderUrl,  
                                               birdsList = birdsList,
                                               rastersPath = rastersPath)

  ## lapply applys the custom function to each raster in turn
  postprocessedRasters <- lapply(X = downloadedRasters, FUN = function(RasterLayer) {
    ## the function postProcesses the layer, cropping and masking it to a given study area and rasterToMatch, and saving it to a given destination path
    proRaster <- postProcess(RasterLayer, 
                             studyArea = studyArea,
                             rasterToMatch = rasterToMatch,
                             destinationPath = rastersPath)
    ## each layer is returned into the object proRaster
    return(proRaster)
  })

  ## Finally the whole function returns the birdRasterStacks
  return(postprocessedRasters)
}
```

Here, we define which bird species we want, where to download the bird density rasters from, and where to save them. It then calls the `loadBirdDensityRaster` function. 

We also download a table giving the number of bootstrapped replicates that existed for each bird species.

```{r callLoad250mBootFunction}
#Specify which bird species to examine/input
birdsList <- c("BAWW", "OVEN") #, "CAWA", "ALFL", "AMCR", "AMGO", "AMPI", "AMRE", "AMRO", "ATSP", "ATTW", "BANS", "BAOR", "BARS", "BBMA", "BBWA", "BBWO", "BCCH", "BEKI", "BGGN", "BHCO", "BHVI", "BLBW", "BLJA", "BLPW", "BOBO", "BOCH", "BOWA", "BRBL", "BRCR", "BRTH", "BTBW", "BTNW", "BWWA",  "CCSP", "CEDW", "CHSP", "CLSW", "CMWA", "COGR", "CONW", "CORA", "COYE", "CSWA", "DEJU", "DOWO", "DUFL", "DUNL", "EABL", "EAKI", "EAPH", "EATO", "EAWP", "EUST", "EVGR", "FISP", "FOSP", "GCFL", "GCKI", "GCSP", "GCTH", "GRAJ", "GRCA", "GRSP", "GRYE", "GWWA", "HAFL", "HAWO", "HETH", "HOLA", "HOSP", "HOWR", "INBU", "KILL", "LALO", "LCSP", "LEFL", "LEYE", "LISP", "MAWA", "MOBL", "MODO", "MOWA", "NAWA", "NESP", "NOCA", "NOFL", "NOPA", "NOWA", "OCWA", "OSFL", "PAWA", "PHVI", "PIGR", "PISI", "PIWA", "PIWO", "PUFI", "RBGR", "RBNU", "RBWO", "RCKI", "RECR", "REVI", "RHWO", "ROPI", "RTHU", "RUBL", "RUGR", "RWBL", "SAVS", "SCTA", "SEWR", "SOGR", "SOSA", "SOSP", "SPGR", "SPSA", "SWSP", "SWTH", "TEWA", "TOSO", "TOWA", "TRES", "UPSA", "VATH", "VEER", "VESP", "WAVI", "WBNU", "WCSP", "WETA", "WEWP", "WIPT", "WISN", "WITU", "WIWA", "WIWR", "WOTH", "WTSP", "WWCR", "YBCU", "YBFL", "YBSA", "YEWA", "YHBL", "YRWA")
folderUrlBird <- "https://drive.google.com/drive/folders/1fCTr2P-3Bh-7Qh4W0SMJ_mT9rpsKvGEA" # give file location 

birdRasterStack <- load250mBootRasters(folderUrl = folderUrlBird,
                                              birdsList = birdsList,
                                              rastersPath = downloadFolderBird,
                                              rasterToMatch = rasterToMatch,
                                              studyArea = studyArea)

noBootsDFLocation <- "https://drive.google.com/file/d/1ldESo9gb6icRD8ZsuPgaEDSIwFjJEe4W"
noBootsDF <- drive_download(file = noBootsDFLocation, 
                            path = file.path(downloadFolderBird, "noBootsDF"),
                            type = "spreadsheet",
                            overwrite = TRUE)
```


# Create data table of bird density by landscape

A `data.table` is created, containing the number of cells of each land cover class that are found in the `landscapeRaster`, and the variance between bootstrap replicates, mean bird density for each land cover class. The variance, and the standard error of this mean density is also calculated and included. 

The first step is to gather the values from the rasters and create a clean dataset.
We then  calculate, for each cover class, the number of cells in this class, the mean bird density, and the variance and standard error for bird density. 

## Get bird dataset

Here the data for each cell's mean bird density and variance between bootstrap replicates is collected in a `data.table`.

```{r functionGetBirdDataset}

getBirdDataset <- function(birdRasterStack, landscapeClassesRasterStack) {
  reproducible::Require("raster")

  meanBirdRasters <- names(birdRasterStack) %>% 
                          str_detect('mean') %>%
                          keep(birdRasterStack, .)
  namesMeanBirdRasters <- names(meanBirdRasters)
  
  birdDatasets <- lapply(X = meanBirdRasters, FUN = function(birdRasterLayer) {
    
    landBirdRasterStack <- raster::addLayer(birdRasterLayer, landscapeClassesRasterStack)
    
    
    ## take the values from the rasters and input them to a data table called cellValues
    cellValues <- data.table(getValues(landBirdRasterStack))
    cellValues <- setnames(cellValues, c( "birdDensity", "landForClass", "age", "forestedStatus"))
    
    
    #get rid of any rows with NA values
    cellValues <- na.omit(cellValues) 
    
    ## make sure landForClass and forestedStatus are categorical rather than numerical
    cellValues$landForClass <- as.factor(cellValues$landForClass) 
    cellValues$forestedStatus <- as.factor(cellValues$forestedStatus)
    
    return(cellValues)
  })
  
  names(birdDatasets) <- namesMeanBirdRasters

  return(birdDatasets)
}
```

```{r getBirdDataset}

landscapeRastersStack <- raster::stack(landscapeRaster, ageRaster, FNFRaster)

birdDatasets <- getBirdDataset(birdRasterStack = birdRasterStack,
                               landscapeClassesRasterStack = landscapeRastersStack )

for (i in names(birdDatasets)) {
  attr(birdDatasets[[i]],"Species") <- i ## attr(birdDatasets$OVEN, "Species")
}


```


#1D post-hoc binning predictions of bird densities by cover type alone

## Get bird densities by cover class

```{r functionGetBirdStatsByClass}
getBirdStatsByClass <- function(birdDatasets) {
  namesBirdsAnalysed <- names(birdDatasets) 
  #base::attr()
  birdStatsByClass <- lapply(X = birdDatasets, FUN = function(singleBirdDataset) {
    print(attr(singleBirdDataset, "Species")) ## TODO: use messages
    flush.console() ## TODO: remove!
    birdStats <- singleBirdDataset[order(-forestedStatus, landForClass) # order the rows by the land cover class
                                   ][,list(classCount = .N, # get the number of cells each cover class
                                           #meanBirdDensity = mean(birdDensity), # get the mean bird density for each cover class
                                           meanBirdDensity = mean(birdDensity), #try log of mean bird density
                                           varBirdDensity = var(birdDensity), # get the variance for bird density for each cover class
                                           seBirdDensity = std.error(birdDensity), # get the standard error for bird density for each cover class
                                           normality = tryCatch(ad.test(birdDensity)$p.value,error = function(cond) { return(NaN) }), #ifelse(mean(birdDensity) > 0, tryCatch(ad.test(birdDensity)$p.value,error = function(cond){return(NA)}), NA),
                                           unimodality =   dip.test(birdDensity)$p.value),
                                     by = list(forestedStatus, landForClass)]

    return(birdStats)
  })
  
  names(birdStatsByClass) <- namesBirdsAnalysed

  return(birdStatsByClass)
}
```

```{r getBirdStatsbyClass}
birdStatsByClass <- getBirdStatsByClass(birdDatasets = birdDatasets)

for (i in names(birdStatsByClass)) {
  attr(birdStatsByClass[[i]], "Species") <- i
} ## TODO: don't repeat yourself. if you need to do the same thing multiple times, use a function
```

## Are the normality and unimodality tests passed?

```{r functionGetAssumptionsSummary}
getAssumptionsSummary <- function(birdStatsTables) {
  namesBirdsAnalysed <- names(birdStatsTables) 
  
  byBirdAssumptions <- lapply(birdStatsTables, FUN = function(x) {
    print(attr(x, "Species")) ## TODO: use messages
    flush.console() ## TODO: remove
    
    ## Normality Proportion 
    norm <- length(x$normality[!is.na(x$normality)])
    if (norm == "0") {
      propNormal <- NA
    } else {
      noNormal <- sum(!(x$normality[!is.na(x$normality)]) > 0.05)
      totalClassesNorm <- length(x$normality[!is.na(x$normality)]) 
      propNormal <- noNormal/totalClassesNorm
    }
    
    ## unimodal proportion
    noUnimodal <- sum(!(x$unimodality > 0.05))
    totalClassesUni <- length(x$unimodality)
    propUnimodal <- noUnimodal/totalClassesUni
    
    # assumptions <- data.table(propUnimodal)
    assumptions <- data.table(propNormal, propUnimodal)
    return(assumptions) 
  })
  
  names(byBirdAssumptions) <- namesBirdsAnalysed
  numberOfSpecies <- length(byBirdAssumptions) 
  
  birdAssumpTab <- rbindlist(byBirdAssumptions, use.names = TRUE, idcol = "birdSp")
  
  ## proportion of species where > 50% cover types are normal
  numberOfSpeciesNorm <- length(birdAssumpTab$propNormal[!is.na(birdAssumpTab$propNormal)]) 
  numberSpNormal <-  sum(!(birdAssumpTab$propNormal[!is.na(birdAssumpTab$propNormal)] < 0.5))
  propSpNormal <- numberSpNormal/numberOfSpeciesNorm
  
  ## proportion of species where > 50% cover types are unimodal
  numberSpUnimodal <- sum(!(birdAssumpTab$propUnimodal < 0.5))
  propSpUnimodal <- numberSpUnimodal / numberOfSpecies
  birdAssumptions <- data.table(propSpNormal, propSpUnimodal)

  return(birdAssumptions)
}
```

```{r getAssumptionsSummary}
assumptionsSummary <- getAssumptionsSummary(birdStatsTables = birdStatsByClass)
```

## Plot mean bird density by land cover class with SE bars

TODO: MAKE WORK BY FOREST STATUS AS WELL AS BY FOREST CLASS

```{r plotbirdStatsbyClass}
plotsBirdStatsByClass <- lapply(X = birdStatsByClass, FUN = function(singleBirdStats) {
  plotBirdStatsByClass <- ggplot(data = singleBirdStats, aes(x = landForClass, y = meanBirdDensity)) +
    geom_bar(stat = "identity", width = 0.7, fill = "steelblue") +
    theme_classic() +
    ggtitle("Mean Ovenbird Density by Cover Class") +
    theme(axis.text = element_text(size = 7)) +
    geom_errorbar(aes(ymin = meanBirdDensity - seBirdDensity, ymax = meanBirdDensity + seBirdDensity), width = .15) 
 
return(plotsBirdStatsByClass)
})
```

# Examine the data using a kernel density plot

### Get Kernel Density Data and Store in Lists

```{r getKernelDensityDataFunction}
getKernelDensityData <- function(birdDatasets) {
  namesBirdsAnalysed <- names(birdDatasets) 
  
  birdKernelDensities <- lapply(X = birdDatasets, FUN = function(singleBirdDataset) {
    namesClasses <- levels(singleBirdDataset$landForClass)
    classKernelDensities <- lapply(X = namesClasses, FUN = function(coverType) {
      dataForDensity <- singleBirdDataset[landForClass == coverType]
      singleClassDensity <- density(dataForDensity[,birdDensity])
      
      return(singleClassDensity)
    })
    
    names(classKernelDensities) <- namesClasses
    return(classKernelDensities)
  })

  names(birdKernelDensities) <- namesBirdsAnalysed
  return(birdKernelDensities)
}
```

```{r getKernelDensityData}
kernelDensityData <- getKernelDensityData(birdDatasets = birdDatasets)
```

## Plot a Particular Kernel Density Data

```{r getKernelDensityPlotFunction}
getKernelDensityPlot <- function(birdCoverDensity, birdName, coverType, meanData) {
  densityPlot <- plot(birdCoverDensity,
                      main = paste0("Kernel Density for ", paste0(birdName), " in CC", coverType),
                      xlab = "Predicted Bird Density",
                      ylab = "Density of predictions") + ## TODO: this is NOT ggplot!
  abline(v = meanData, col = "red")
  return(densityPlot)
}
```

```{r getKernelDensityPlot}
kernelDensityPlot <- getKernelDensityPlot(birdName = "Ovenbird", #sp name for title
                                          coverType = "7", #cover type name for title
                                          birdCoverDensity = kernelDensityData$OVEN$"7", #which kernel density cover type and bird species to plot
                                          meanData = birdStatsByClass$OVEN[7,meanBirdDensity] #show a red line with the mean density
)
#which sp and cover type to graph 
```

```{r plotVarBirdDensity}
# plotsVarBirdDensity <- lapply(X = birdStatsByClass,
#                               FUN = function(singleBirdStats){
#                                 
# plotVarBirdDensity <- ggplot(data = singleBirdStats, aes(x =landForClass, y = varBirdDensity)) + geom_bar(stat="identity")
# 
# return(plotVarBirdDensity)
# 
# })
```

# 2D problem - Using BRTs to create a matrix of predicted bird density by age and cover class

- do this for forested areas only
- for the test-case we can fit brt with n = 1400000, but may take time if it is more. 
- to predict, need prediction df that gives the mid-points of the target age classes in the final matrix, and forest types (function expand?)
- convert results to a matrix rows = forest types, columns = 10 year age classes

```{r fitBRT }

ageGrouping <- 10

birdMatricies <- lapply(X = birdDatasets, FUN = function(birdDF) {


#separate out data table rows that are forested
forestedDF <- birdDF[forestedStatus == "1"]
forestedDF <- droplevels(forestedDF)

#fit gbm
birdData <- forestedDF
gbmFitted <- gbm::gbm(formula = birdDensity ~ landForClass + age, distribution = "gaussian", data = birdData, interaction.depth = 2, n.trees = 100) #same number of trees as used in predict.gbm

#generate prediction df using expand(?)
maxAge <- max(birdData$age)
allAges <- c(1:maxAge)
birdPredictDF <- birdData %>% expand(landForClass, allAges)
names(birdPredictDF) <- c("landForClass", "age")

#do prediction 
#(object, newdata, n.trees, type = "link", single.tree = FALSE,...)
gbmPred <- gbm::predict.gbm(object = gbmFitted,
                 newdata = birdPredictDF,
                 n.trees = 100, 
                 type = "link", 
                 single.tree = FALSE)  
  
#bin ages into age classes according to the value of ageGrouping 
#I need to get average of every ten columns into one
noAgeClasses <- maxAge/ageGrouping
ageClasses <- rep(1:noAgeClasses, each = ageGrouping)
maxAgeClass <- 15
ageClasses <- ifelse(ageClasses < maxAgeClass, ageClasses, maxAgeClass)
gbmPredDF <- cbind(birdPredictDF, gbmPred, ageClasses)
#TODO in the future add weight averages by gbm prediction variance
gbmPredDF <- aggregate( gbmPred ~ ageClasses + landForClass, gbmPredDF, mean )
 

#form matrix with landForClass as y axis and age as x axis
birdMatrix <- reshape2::acast(gbmPredDF, 
                              landForClass~ageClasses, 
                              value.var= "gbmPred")

      return(birdMatrix)
   
    })

```

```{r packageOutputResults }

#get non-Forest 1D data together
nonforBirdPreds <- lapply(X = birdDatasets, FUN = function(singleBirdDF) {

#separate out data table rows that are forested, get rid of unnecessary forestedStatus column
nonforestedDF <- singleBirdDF[forestedStatus == "0"]
nonforestedDF <- subset(nonforestedDF, select = c("birdDensity", "landForClass", "age"))
nonforestedDF <- droplevels(nonforestedDF)

return(nonforestedDF)
})

#make list object of all module outputs needed for Mapping Module 
birdPreds <- list(birdMatricies, nonforBirdPreds, ageGrouping) #TODO give age and ageclass in table not just ageGrouping
names(birdPreds) <- c("birdMatrices", "nonforBirdPreds", "ageClassSize")

```

#NEXT MODULE: MAPPING MODULE

Inputs: birdPreds, a raster of cover, a raster of age
Outputs: raster brick of bird density precictions across the landscape for bird sps in birdPreds 

1) get inputs
      - crop and mask the rasters of cover/age to the study area? 
2) determine which areas of landscape are forest and non forest
      - (using FNFRaster? do I need to add that to birdPreds inputs?)- YES
3) if not already done, reclassify the landscape/forest cover and age rasters according to age and cover classes we have given
      - use Ana's module for the landscape/forest classes  - YES, ANA WILL PROVIDE
4) create a raster of bird densities across the non-forested areas of the landscape 
      -reclassify() function to reclassify non-forested areas using nonForBirdPreds as the reclassification matrix
      - to do this will have to reform nonForBirdPreds into a matrix using matrix(), and get rid of the age data
5) create a raster of bird densities across the forested areas 
      - do this based on the forest cover and age class rasters stacked together and the birdMatrices
      - what function is best for this? 
6) put non-forested and forested rasters together into one raster of birdDensities using cover() function
7) output this raster from the module

