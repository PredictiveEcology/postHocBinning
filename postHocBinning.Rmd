---
title: "Post-Hoc Binning"
author: "Isolde Lane-Shaw"
date: "6/11/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In order to manage and conserve bird species within the boreal forest is is necessary to be able to predict bird species abundance across future/hypothetical landscapes, based off of reliable models and data. To this end, a series of national models of bird density have been created based off the Boreal Avian Modelling (BAM) Project dataset (Boreal Avian Modelling Project, 2020). The BAM dataset is a collation of over 100 avian studies from across the Canadian boreal region (the majority of which comprise point-count data). In the most recent version of these models, a series of bootstrapped bird density predictions for the Canadian boreal region are output as rasters, at a resolution of 250m2. 

Due to the heterogenous nature of the environment and the extensive quantity of data available in these rasters a degree of simplification is necessary in order to make predictions about bird abundance on future or hypothetical landscapes. To this end, this module serves to distill the  bird density predictions data, grouping it according to broad forest and land cover types. 

This module calculates predicted bird densities from the mean of the most recent bootstrapped BAM national models of bird density rasters, for each of a given set of cover and age classes according to two different methods:
  - 1D, where a single variable, underlying cover class, is used to bin data points of predicted bird density, by calculating the mean. This method is used for both forested and non-forested cover classes.
  - 2D, where a gbm is used to give a predicted bird density according the combination of two variables, cover class and age. The predicted bird densities are then further binned according to the mean value of the desired age classes. This method is used for forested cover classes only.  

# Load essential packages and setup directories

```{r packages}
library(Require)

#list packages to load
Require("data.table")
Require("rgdal")
Require("sf")
Require("raster")
Require("SpaDES.core") ## TODO: not used
Require("LandR")
Require("googledrive")
Require("plotrix") 
Require("ggplot2")
Require("ggpubr")
Require("diptest")
Require("nortest")
Require("gbm")
Require("dplyr")
Require("tidyverse")
Require("reshape2")
#Require("tidyr")

inputsDir <- checkPath("inputs", create = TRUE)
outputsDir <- checkPath("outputs", create = TRUE)

downloadFolderArea <- checkPath(file.path(inputsDir, "studyArea"), create = TRUE)
downloadFolderBird <- checkPath(file.path(inputsDir, "birdRasterFiles"), create = TRUE)
downloadFolderForestClass <- checkPath(file.path(inputsDir, "forestClassRasters"), create = TRUE)
```


#Get rasterToMatch and study area files

Here the LLC2005 raster layer of Canada is read in using the `LandR::prepInputsLCC` function.
It will be used as the `rasterToMatch` layer for other spatial layers to reproject, crop and mask to.

```{r LCC2005}
rasterToMatch <- LandR::prepInputsLCC(destinationPath = inputsDir) 
```


##Define Study Area

The study area that we are interested in is then downloaded and read in using the prepInputs function. In this example we are using an area of North-East British Columbia. 

```{r studyArea, echo=FALSE}
nameAreaShapefile <- "BCR6_BC.shp" #specify file name
folderUrlArea <- "https://drive.google.com/file/d/1SjUKXOcNqDUkRxRTjwgLlLFjb5LRzbHy"
archiveArea <- "BCR6_BC.zip" #give archive name

studyArea <- prepInputs(targetFile = nameAreaShapefile, 
                        url = folderUrlArea,
                        archive = archiveArea, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderArea, #save the file to a folder in the working directory called studyArea
                        fun = "raster::shapefile", #use the function shapefile
                        targetCRS = crs(rasterToMatch),
                        #rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        overwrite = TRUE,
                        verbose = TRUE)
# studyArea <- spTransform(studyArea, crs(rasterToMatch))

rasterToMatch <- raster::crop(rasterToMatch, studyArea) #create landscapeRaster by cropping rasterToMatch to studyArea
rasterToMatch <- raster::mask(rasterToMatch, studyArea) #mask landscapeRaster to studyArea
#landscapeRasters <- unstack(landscapeRastersStack)

```


# Get Landscape Data

Here we download and load the rasters giving data on the landscape. 

## Input land cover class rasters

First we download a raster that gives the forest cover types, in forested areas.

```{r getForClassRaster}

nameForClassRaster <- "VegTypeABBC.tif" #specify file name
folderUrlForClass <- "https://drive.google.com/file/d/1cfrb-RhiwMD4XlS_yzRSQYPVh8ffwC0L/view?usp=sharing"
archiveForClass <- "vegTypeABBC.zip" #give archive name

forClassRaster <- prepInputs(targetFile = nameForClassRaster, 
                        url = folderUrlForClass,
                        archive = archiveForClass, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        useCache = getOption("reproducible.useCache", FALSE),
                        overwrite = TRUE,
                        verbose = TRUE)

names(forClassRaster) <- c("forClassRaster")

forClassRaster[forClassRaster == 0] <- NA

# #rename the categories found in the rasters
# namesValues <- as.factor(unique(forClassRaster))
# newVals <- unlist(lapply(X = namesValues, FUN = function(x) {
# newVal <-  as.factor(paste0("FR", x))
#     return(newVal)
#   }))
# reclassVector <- c(rbind(namesValues, newVals))
# reclassMatrix <- matrix(reclassVector,
#                               ncol=2, byrow = TRUE)
# forClassRaster <- reclassify(forClassRaster,
#                      reclassMatrix)

plot(forClassRaster) #visually check forClassRaster

```

Then we input a raster that gives cover types in non forested areas. In this example the LCC05 map of Canada is used. 

```{r getNonForRaster}

nameNonForRaster <- "LCC2005_V1_4a.tif" #specify file name
folderUrlNonFor <- "https://drive.google.com/file/d/1E3iQRfaSPx0-b2GTgbLZqjo2Nhom39EK/view?usp=sharing"
archiveNonFor <- "LCC2005_V1_4a.zip" #give archive name

nonForRaster <- prepInputs(targetFile = nameNonForRaster, 
                        url = folderUrlNonFor,
                        archive = archiveNonFor, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        useCache = getOption("reproducible.useCache", FALSE),
                        overwrite = TRUE,
                        verbose = TRUE)

names(nonForRaster) <- c("nonForRaster")

nonForRaster <- overlay(x = nonForRaster, y = forClassRaster, fun = function(x, y) {
                         x[!is.na(y[])] <- NA
                          return(x)
                            })

#rename the categories found in the rasters
# namesValues <- unique(nonForRaster)
# newVals <- unlist(lapply(X = namesValues, FUN = function(x) {
# newVal <-  as.factor(paste0("NF", x))    
#     return(newVal)
#   }))
# reclassVector <- c(rbind(namesValues, newVals))
# reclassMatrix <- matrix(reclassVector, 
#                               ncol=2, byrow = TRUE)
# nonForRaster <- reclassify(nonForRaster,
#                      reclassMatrix)

plot(nonForRaster) #visually check nonForRaster

```

We then combine the nonForRaster and the forClassRaster so that we have a single raster giving the cover types (both forested and non-forested) over the study region. 

```{r createLandscapeRaster}

landscapeRaster <- cover(x = forClassRaster,
                         y = nonForRaster,
                         filename = "landscapeRaster",
                         overwrite = TRUE )

names(landscapeRaster) <- c("landscapeRaster")

plot(landscapeRaster) #visually check nonForRaster

```

## Create raster giving status of the landcover as forested or non-forested

This is based on the presence or abscence of data in the forClassRaster.

```{r createFNFRaster}

#create a raster that gives if an area is forest or not (0 for non-forest, 1 for forest)
#This will allow me to have a value in the birdDataset that says if a cell was forested or not

#make forest 1
valsFR <- unique(forClassRaster)
newValFR <-  as.factor(rep("1", length(valsFR)))
newValsFR <- cbind(valsFR, newValFR)
reclassMatrixFR <- matrix(newValsFR, 
                              ncol=2, byrow = FALSE)
rasterFR <- reclassify(forClassRaster,
                     reclassMatrixFR)

#make the rest 0 
replaceNA <- function(x, na.rm, ...){ 
  if(is.na(x[1]))
    return(0)
  else
    return(x)
} 

FNFRaster <- calc(rasterFR, fun = replaceNA)
#mask back down to size again
FNFRaster <- raster::mask(FNFRaster,rasterToMatch)

names(FNFRaster) <- c("FNFRaster")

plot(FNFRaster) #visually check FNFRaster

```

## Age Raster Input 

Finally, we input a raster that gives the ages of the forested areas in age classes. 

```{r getForAgeRaster}

nameForAgeRaster <- "ageRas.tif" #specify file name
folderUrlAge <- "https://drive.google.com/file/d/1Ih4YLfIYX6nQcotdd41j4yRtZKRQxYo7/view?usp=sharing"
archiveAge <- "ageRaster.zip" #give archive name

forAgeRaster <- prepInputs(targetFile = nameForAgeRaster, 
                        url = folderUrlAge,
                        archive = archiveAge, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        overwrite = TRUE,
                        verbose = TRUE)

names(forAgeRaster) <- c("forAgeRaster")

plot(forAgeRaster) #visually check ageRaster
```

### Get KNN age raster to fill in non forested ages

```{r getkNNAgeRaster}

namekNNAgeRaster <- "NFI_MODIS250m_2011_kNN_Structure_Stand_Age_v1.tif" #specify file name
folderUrlkNNAge <- "https://drive.google.com/file/d/1Ih4YLfIYX6nQcotdd41j4yRtZKRQxYo7/view?usp=sharing"
archivekNNAge <- "ageRaster.zip" #give archive name

kNNAgeRaster <- prepInputs(targetFile = namekNNAgeRaster, 
                        url = folderUrlkNNAge,
                        archive = archivekNNAge, 
                        alsoExtract = "similar", #Extract other files with similar names
                        destinationPath = downloadFolderForestClass, #save the file to a folder in the working directory called forestClassRasters
                        fun = "raster::raster", #use the function raster
                        #targetCRS = crs(rasterToMatch),
                        rasterToMatch = rasterToMatch, #use the specified rasterToMatch to reproject to
                        studyArea = studyArea,
                        overwrite = TRUE,
                        verbose = TRUE)

names(kNNAgeRaster) <- c("kNNAgeRaster")

plot(kNNAgeRaster) #visually check kNNAgeRaster
```

```{r createAgeRaster}

ageRaster <- cover(x = forAgeRaster,
                         y = kNNAgeRaster,
                         filename = "ageRaster",
                         overwrite = TRUE )

names(ageRaster) <- c("ageRaster")

plot(ageRaster) #visually check nonForRaster

```

# Get Bird Density Data

## Download/load 250m bootstrapped bird rasters for mean and variance, and the DF giving numbers of bootstrap replicates the rasters were derived from.

Multiple rasters of predicted bird density are downloaded, postProcessed, loaded and output as a raster stack, alongside rasters giving the variance between bootstraps at each pixel. 

To do this we first define a function to download rasters for the chosen bird species, and output a list of the rasters that have been downloaded. 

```{r functionDownload250mBootRasters}
download250mBootRasters <-
  function(folderUrl, birdsList, rastersPath) {
    ## drive_ls function is used to list all the files it finds using the folder url with the given pattern
    filesToDownload <-
      googledrive::drive_ls(path = as_id(folderUrl)) #note: has to be changed if filenaming system changes
    ## grepl function searches for all items in the filesToDownload that are on birdList & stores their names in rastersforBirdList
    rastersForBirdList <-
      filesToDownload$name[grepl(pattern = paste(birdsList, collapse = "|"),
                                 x = filesToDownload$name)]
    
    ## for each item in turn from rastersForBirdlist the following function is applied:
    downloadedRasters <-
      lapply(
        X = rastersForBirdList,
        FUN = function(rasterFile) {
          ## if the item in rastersForBirdList is not already present at rastersPath, googledrive package downloads it
          if (!file.exists(file.path(rastersPath, rasterFile))) {
            googledrive::drive_download(
              file = as_id(filesToDownload[filesToDownload$name %in% rasterFile,]$id),
              #rasterFile,
              path = file.path(rastersPath, rasterFile),
              overwrite = TRUE
            )
          }
          
          ## otherwise, if it is already present and downloaded, just get the name of the item
          return(raster(file.path(rastersPath, rasterFile), verbose = TRUE))
        }
      )
    
    #get the species codes as names for the downloadedRasters object, rather than using the whole filepath
    X <-
      lapply(rastersForBirdList, substr, 1, 8) #works for strings of the form "varsXXXX" or "meanXXXX"
    names(downloadedRasters) <- X
    #the downloadBirdDensityRasters function returns/loads the downloaded rasters
    return(downloadedRasters)
  }
```

The download bird function is called by a second defined function, which postprocesses (reprojects, crops and masks according to the given rasterToMatch and studyArea) and loads the rasters in a raster stack.   

```{r functionLoad250mBootRasters}
load250mBootRasters <- function(birdsList,
                                folderUrl,
                                rastersPath,
                                rasterToMatch,
                                studyArea) {
  reproducible::Require("raster")
  ## check that there is a folder at the given rastersPath. if not, create it. 
  rastersPath <- checkPath(file.path(rastersPath), create = TRUE) 
  ## download the rasters on the birdList. Return List of downloaded files.
  downloadedRasters <- download250mBootRasters(folderUrl = folderUrl,  
                                               birdsList = birdsList,
                                               rastersPath = rastersPath)

  ## lapply applys the custom function to each raster in turn
  postprocessedRasters <- lapply(X = downloadedRasters, FUN = function(RasterLayer) {
    ## the function postProcesses the layer, cropping and masking it to a given study area and rasterToMatch, and saving it to a given destination path
    proRaster <- postProcess(RasterLayer, 
                             studyArea = studyArea,
                             rasterToMatch = rasterToMatch,
                             destinationPath = rastersPath)
    ## each layer is returned into the object proRaster
    return(proRaster)
  })

  ## Finally the whole function returns the birdRasterStacks
  return(postprocessedRasters)
}
```

Here, we define which bird species we want, where to download the bird density rasters from, and where to save them. It then calls the `loadBirdDensityRaster` function. 

We also download a table giving the number of bootstrapped replicates that existed for each bird species.

```{r callLoad250mBootFunction}
#Specify which bird species to examine/input
birdsList <- c("BAWW", "OVEN") #, "CAWA", "ALFL", "AMCR", "AMGO", "AMPI", "AMRE", "AMRO", "ATSP", "ATTW", "BANS", "BAOR", "BARS", "BBMA", "BBWA", "BBWO", "BCCH", "BEKI", "BGGN", "BHCO", "BHVI", "BLBW", "BLJA", "BLPW", "BOBO", "BOCH", "BOWA", "BRBL", "BRCR", "BRTH", "BTBW", "BTNW", "BWWA",  "CCSP", "CEDW", "CHSP", "CLSW", "CMWA", "COGR", "CONW", "CORA", "COYE", "CSWA", "DEJU", "DOWO", "DUFL", "DUNL", "EABL", "EAKI", "EAPH", "EATO", "EAWP", "EUST", "EVGR", "FISP", "FOSP", "GCFL", "GCKI", "GCSP", "GCTH", "GRAJ", "GRCA", "GRSP", "GRYE", "GWWA", "HAFL", "HAWO", "HETH", "HOLA", "HOSP", "HOWR", "INBU", "KILL", "LALO", "LCSP", "LEFL", "LEYE", "LISP", "MAWA", "MOBL", "MODO", "MOWA", "NAWA", "NESP", "NOCA", "NOFL", "NOPA", "NOWA", "OCWA", "OSFL", "PAWA", "PHVI", "PIGR", "PISI", "PIWA", "PIWO", "PUFI", "RBGR", "RBNU", "RBWO", "RCKI", "RECR", "REVI", "RHWO", "ROPI", "RTHU", "RUBL", "RUGR", "RWBL", "SAVS", "SCTA", "SEWR", "SOGR", "SOSA", "SOSP", "SPGR", "SPSA", "SWSP", "SWTH", "TEWA", "TOSO", "TOWA", "TRES", "UPSA", "VATH", "VEER", "VESP", "WAVI", "WBNU", "WCSP", "WETA", "WEWP", "WIPT", "WISN", "WITU", "WIWA", "WIWR", "WOTH", "WTSP", "WWCR", "YBCU", "YBFL", "YBSA", "YEWA", "YHBL", "YRWA")
folderUrlBird <- "https://drive.google.com/drive/folders/1fCTr2P-3Bh-7Qh4W0SMJ_mT9rpsKvGEA" # give file location 

birdRasterStack <- load250mBootRasters(folderUrl = folderUrlBird,
                                              birdsList = birdsList,
                                              rastersPath = downloadFolderBird,
                                              rasterToMatch = rasterToMatch,
                                              studyArea = studyArea)

noBootsDFLocation <- "https://drive.google.com/file/d/1ldESo9gb6icRD8ZsuPgaEDSIwFjJEe4W"
noBootsDF <- drive_download(file = noBootsDFLocation, 
                            path = file.path(downloadFolderBird, "noBootsDF"),
                            type = "spreadsheet",
                            overwrite = TRUE)
```


# Create data table of bird density by landscape

A `data.table` is created, containing the number of cells of each land cover class that are found in the `landscapeRaster`, and the variance between bootstrap replicates, mean bird density for each land cover class. The variance, and the standard error of this mean density is also calculated and included. 

The first step is to gather the values from the rasters and create a clean dataset. We then  calculate, for each cover class, the number of cells in this class, the mean bird density, and the variance and standard error for bird density. 

## Get bird dataset

Here the data for each cell's mean bird density and variance between bootstrap replicates is collected in a `data.table`, alongside the corresponding landscape and age raster cells.

```{r functionGetBirdDataset}

getBirdDataset <- function(birdRasterStack, landscapeClassesRasterStack) {
  reproducible::Require("raster")

  meanBirdRasters <- names(birdRasterStack) %>% 
                          str_detect('mean') %>%
                          keep(birdRasterStack, .)
  namesMeanBirdRasters <- names(meanBirdRasters)
  
  birdDatasets <- lapply(X = meanBirdRasters, FUN = function(birdRasterLayer) {
    
    landBirdRasterStack <- raster::addLayer(birdRasterLayer, landscapeClassesRasterStack)
    
    
    ## take the values from the rasters and input them to a data table called cellValues
    cellValues <- data.table(getValues(landBirdRasterStack))
    cellValues <- setnames(cellValues, c( "birdDensity", "landForClass", "age", "forestedStatus"))
    cellValues <- unite(cellValues, uniqueLandClass, c(forestedStatus, landForClass), remove=FALSE)
    
    #get rid of any rows with NA values
    cellValues <- na.omit(cellValues) 
    
    ## make sure landForClass and forestedStatus are categorical rather than numerical
    cellValues$landForClass <- as.factor(cellValues$landForClass) 
    cellValues$forestedStatus <- as.factor(cellValues$forestedStatus)
    cellValues$uniqueLandClass <- as.factor(cellValues$uniqueLandClass)
    
    return(cellValues)
  })
  
  names(birdDatasets) <- namesMeanBirdRasters

  return(birdDatasets)
}
```

```{r getBirdDataset}

landscapeRastersStack <- raster::stack(landscapeRaster, ageRaster, FNFRaster)

birdDatasets <- getBirdDataset(birdRasterStack = birdRasterStack,
                               landscapeClassesRasterStack = landscapeRastersStack )

for (i in names(birdDatasets)) {
  attr(birdDatasets[[i]],"Species") <- i ## attr(birdDatasets$OVEN, "Species")
}


```


#1D post-hoc binning predictions of bird densities by cover type alone

## Get bird densities by cover class and calculate statistics

```{r functionGetBirdStatsByClass}
getBirdStatsByClass <- function(birdDatasets) {
  namesBirdsAnalysed <- names(birdDatasets) 
  #base::attr()
  birdStatsByClass <- lapply(X = birdDatasets, FUN = function(singleBirdDataset) {
    print(attr(singleBirdDataset, "Species")) ## TODO: use messages
    flush.console() ## TODO: remove!
    birdStats <- singleBirdDataset[order(-forestedStatus, landForClass) # order the rows by the land cover class
                                   ][,list(classCount = .N, # get the number of cells each cover class
                                           #meanBirdDensity = mean(birdDensity), # get the mean bird density for each cover class
                                           meanBirdDensity = mean(birdDensity), #try log of mean bird density
                                           varBirdDensity = var(birdDensity), # get the variance for bird density for each cover class
                                           seBirdDensity = std.error(birdDensity), # get the standard error for bird density for each cover class
                                           normality = tryCatch(ad.test(birdDensity)$p.value,error = function(cond) { return(NaN) }), #ifelse(mean(birdDensity) > 0, tryCatch(ad.test(birdDensity)$p.value,error = function(cond){return(NA)}), NA),
                                           unimodality =   dip.test(birdDensity)$p.value),
                                     by = list(forestedStatus, landForClass)]
    
    birdStats <- unite(birdStats, uniqueLandClass, c(forestedStatus, landForClass), remove=FALSE)

    return(birdStats)
  })
  
  names(birdStatsByClass) <- namesBirdsAnalysed

  return(birdStatsByClass)
}
```

```{r getBirdStatsbyClass}
birdStatsByClass <- getBirdStatsByClass(birdDatasets = birdDatasets)

for (i in names(birdStatsByClass)) {
  attr(birdStatsByClass[[i]], "Species") <- i
} ## TODO: don't repeat yourself. if you need to do the same thing multiple times, use a function

```


##Explore the produced 1D bird density predictions

### Are the normality and unimodality tests passed?

```{r functionGetAssumptionsSummary}
getAssumptionsSummary <- function(birdStatsTables) {
  namesBirdsAnalysed <- names(birdStatsTables) 
  
  byBirdAssumptions <- lapply(birdStatsTables, FUN = function(x) {
    print(attr(x, "Species")) ## TODO: use messages
    flush.console() ## TODO: remove
    
    ## Normality Proportion 
    norm <- length(x$normality[!is.na(x$normality)])
    if (norm == "0") {
      propNormal <- NA
    } else {
      noNormal <- sum(!(x$normality[!is.na(x$normality)]) > 0.05)
      totalClassesNorm <- length(x$normality[!is.na(x$normality)]) 
      propNormal <- noNormal/totalClassesNorm
    }
    
    ## unimodal proportion
    noUnimodal <- sum(!(x$unimodality > 0.05))
    totalClassesUni <- length(x$unimodality)
    propUnimodal <- noUnimodal/totalClassesUni
    
    # assumptions <- data.table(propUnimodal)
    assumptions <- data.table(propNormal, propUnimodal)
    return(assumptions) 
  })
  
  names(byBirdAssumptions) <- namesBirdsAnalysed
  numberOfSpecies <- length(byBirdAssumptions) 
  
  birdAssumpTab <- rbindlist(byBirdAssumptions, use.names = TRUE, idcol = "birdSp")
  
  ## proportion of species where > 50% cover types are normal
  numberOfSpeciesNorm <- length(birdAssumpTab$propNormal[!is.na(birdAssumpTab$propNormal)]) 
  numberSpNormal <-  sum(!(birdAssumpTab$propNormal[!is.na(birdAssumpTab$propNormal)] < 0.5))
  propSpNormal <- numberSpNormal/numberOfSpeciesNorm
  
  ## proportion of species where > 50% cover types are unimodal
  numberSpUnimodal <- sum(!(birdAssumpTab$propUnimodal < 0.5))
  propSpUnimodal <- numberSpUnimodal / numberOfSpecies
  birdAssumptions <- data.table(propSpNormal, propSpUnimodal)

  return(birdAssumptions)
}
```

```{r getAssumptionsSummary}
assumptionsSummary <- getAssumptionsSummary(birdStatsTables = birdStatsByClass)
```

### Plot mean bird density by cover class with SE bars

```{r plotbirdStatsbyClass}

plotsMeanBirdDensity <- lapply(X = birdStatsByClass,
                              FUN = function(singleBirdStats){
                                
plotMeanBirdDensity <- ggplot(data = singleBirdStats, aes(x = uniqueLandClass, y = meanBirdDensity, fill = forestedStatus)) +
    geom_bar(stat = "identity", width = 0.7) +
    theme_classic() +
    ggtitle(paste0("Mean bird density by cover class")) +
    xlab("Cover Class") +
    theme(axis.text = element_text(size = 6)) +
    geom_errorbar(aes(ymin = meanBirdDensity - seBirdDensity, ymax = meanBirdDensity + seBirdDensity), width = .15) 
 
return(plotMeanBirdDensity)

})

plotsMeanBirdDensity$meanOVEN #show an example
```

### Plot variance in bird density by cover class 

```{r plotVarBirdDensity}

plotsVarBirdDensity <- lapply(X = birdStatsByClass,
                              FUN = function(singleBirdStats){

plotVarBirdDensity <- ggplot(data = singleBirdStats, aes(x =uniqueLandClass, y = varBirdDensity, fill = forestedStatus)) + 
   theme_classic() +
  ggtitle(paste0("Variance in bird density by cover class")) +
  xlab("Cover Class") +
    theme(axis.text = element_text(size = 6)) +
  geom_bar(stat = "identity", width = 0.7) 

return(plotVarBirdDensity)

})

plotsVarBirdDensity$meanOVEN #show an example
```



### Examine the data using a kernel density plot

#### Get Kernel Density Data 

```{r getKernelDensityDataFunction}
getKernelDensityData <- function(birdDatasets) {
  namesBirdsAnalysed <- names(birdDatasets) 
  
  birdKernelDensities <- lapply(X = birdDatasets, FUN = function(singleBirdDataset) {
    namesClasses <- levels(singleBirdDataset$uniqueLandClass)
      classKernelDensities <- lapply(X = namesClasses, FUN = function(coverType) {
      dataForDensity <- singleBirdDataset[uniqueLandClass == coverType]
      singleClassDensity <- density(dataForDensity[,birdDensity])
      
      return(singleClassDensity)
    })
    
    names(classKernelDensities) <- namesClasses
    return(classKernelDensities)
  })

  names(birdKernelDensities) <- namesBirdsAnalysed
  return(birdKernelDensities)
}
```

```{r getKernelDensityData}
kernelDensityData <- getKernelDensityData(birdDatasets = birdDatasets)
```

#### Plot an Example Kernel Density Data

```{r getKernelDensityPlotFunction}
getKernelDensityPlot <- function(birdCoverDensity, birdName, coverType, meanData) {
  densityPlot <- plot(birdCoverDensity,
                      main = paste0("Kernel Density for ", paste0(birdName), " in CC", coverType),
                      xlab = "Predicted Bird Density",
                      ylab = "Density of predictions") 
  return(densityPlot)
}
```

```{r getKernelDensityPlot}
kernelDensityPlot <- getKernelDensityPlot(birdName = "Ovenbird", #sp name for title
                                          coverType = "7, forested", #cover type name for title
                                          birdCoverDensity = kernelDensityData$meanOVEN$"1_7") #which kernel density cover type and bird species to plot 
```



# 2D problem - Using BRTs to create a matrix of predicted bird density by age and cover class

This is carried out for forested cover classes only.
 
```{r fitBRT }

#PARAMETER: define how you want the age classes to be 
ageGrouping <- 10 #how many years included per age class
maxAgeClass <- 15 #what the oldest age class will be (everything older will be included in this class)

birdMatricies <- lapply(X = birdDatasets, FUN = function(birdDF) {


#separate out data table rows that are forested
forestedDF <- birdDF[forestedStatus == "1"]
forestedDF <- droplevels(forestedDF)

#fit gbm
birdData <- forestedDF
gbmFitted <- gbm::gbm(formula = birdDensity ~ landForClass + age, distribution = "gaussian", data = birdData, interaction.depth = 2, n.trees = 100) #same number of trees as used in predict.gbm

#generate prediction df using expand(?)
maxAge <- max(birdData$age)
allAges <- c(1:maxAge)
birdPredictDF <- birdData %>% expand(landForClass, allAges)
names(birdPredictDF) <- c("landForClass", "age")

#do prediction 
#(object, newdata, n.trees, type = "link", single.tree = FALSE,...)
gbmPred <- gbm::predict.gbm(object = gbmFitted,
                 newdata = birdPredictDF,
                 n.trees = 100, 
                 type = "link", 
                 single.tree = FALSE)  
  
#bin ages into age classes according to the value of ageGrouping 
#I need to get average of every ten columns into one
noAgeClasses <- maxAge/ageGrouping
ageClasses <- rep(1:noAgeClasses, each = ageGrouping)
ageClasses <- ifelse(ageClasses < maxAgeClass, ageClasses, maxAgeClass)
gbmPredDF <- cbind(birdPredictDF, gbmPred, ageClasses)
#TODO in the future add weight averages by gbm prediction variance
gbmPredDF <- aggregate( gbmPred ~ ageClasses + landForClass, gbmPredDF, mean )
 

#form matrix with landForClass as y axis and age as x axis
birdMatrix <- reshape2::acast(gbmPredDF, 
                              landForClass~ageClasses, 
                              value.var= "gbmPred")

      return(birdMatrix)
   
    })

```

### Gather together data to be output by module

```{r separateNonForStat}

#get non-Forest 1D data together
nonforBirdPreds <- lapply(X = birdStatsByClass, FUN = function(singleBirdDF) {

#separate out data table rows that are forested, get rid of unnecessary forestedStatus column
nonforestedDF <- singleBirdDF[forestedStatus == "0"]
nonforestedDF <- subset(nonforestedDF, select = c("landForClass", "meanBirdDensity", "varBirdDensity", "seBirdDensity", "normality", "unimodality"))
nonforestedDF <- droplevels(nonforestedDF)

return(nonforestedDF)
})

```

```{r packageOutputResults }

# create table defining age classes for forested areas

#use the first data table on the birdDatasets list 
singleBirdDT <- birdDatasets[[1]]

#separate out data table rows that are forested
forestedDT <- singleBirdDT[forestedStatus == "1"]
forestedDT <- droplevels(forestedDT)

# create table defining age classes
maxAge <- max(forestedDT$age) #find max age of forest
allAges <- c(0:maxAge) #make vector counting from 1 to to max age
agesOverMaxAgeClass <- maxAge-(maxAgeClass*ageGrouping) 
ageClasses <- c(1, rep(1:maxAgeClass, each = ageGrouping), rep(maxAgeClass, times = agesOverMaxAgeClass)) #make vector of age classes to correspond with the vector allAges
ageClassDefs <- cbind(allAges,ageClasses) 
ageClassDefs <- as.data.table(ageClassDefs) # put together in ageClassDefs data table
ageClassDefs <- ageClassDefs[, ageClasses:=as.character(ageClasses)] 


#make list object of all outputs needed for Mapping Module 
birdPreds <- list(birdMatricies, nonforBirdPreds, ageClassDefs) 
names(birdPreds) <- c("birdMatrices", "nonforBirdPreds", "ageClassDefs")

```

### Do Stats for 2D Binning

```{r 2DStats }

### PARAMETER: exclude any classes from table that have a sample size smaller than minStatsSample
minStatsSample <- 100 

#create birdStats2D (MODULE OUTPUT), a list of lists giving a birdStats2D data table and vector classesNotPresent for each bird species on the birdList.
birdStats2D <- lapply(X = birdDatasets, FUN = function(singleBirdDT) {

#separate out data table rows that are forested from the raw birdDataset 
forestedDT <- singleBirdDT[forestedStatus == "1"]
forestedDT <- droplevels(forestedDT)

#get age classes for each row using the ageClassDefs table
ageClass <- forestedDT[, age]
ageClass <- as.data.table(ageClass)
ageClass[] <- lapply(ageClass, function(x) ageClassDefs$ageClasses[match(x, ageClassDefs$allAges)])
#add the ageClass to the forestedDT 
birdDataNew <- cbind(forestedDT, ageClass)

#create new column, landAgeClass, giving the uniqueLandClass and ageClass combined
birdDataNew <- unite(birdDataNew, landAgeClass, c(uniqueLandClass, ageClass), sep= ".", remove=FALSE)

#produce data table of statistics on the bird Data based on the 2D bins
singleBirdStats2D <- birdDataNew[order(landAgeClass) # order the rows by the land cover class
                                   ][,list(classCount = .N, # get the number of cells each cover class
                                           meanBirdDensity = mean(birdDensity), #get mean bird density
                                           varBirdDensity = var(birdDensity), # get the variance for bird density for each class
                                           seBirdDensity = std.error(birdDensity), # get the standard error for bird density for each  class
                                           normality = tryCatch(ad.test(birdDensity)$p.value,error = function(cond) { return(NaN) }), #ifelse(mean(birdDensity) > 0, tryCatch(ad.test(birdDensity)$p.value,error = function(cond){return(NA)}), NA),
                                           unimodality =   dip.test(birdDensity)$p.value),
                                     by = list(landAgeClass)]

#exclude any classes from table that have a sample size smaller than minStatsSample, a parameter
singleBirdStats2D <- subset(singleBirdStats2D, classCount > minStatsSample)

#### get list of missing classes
landAgeClassesPresent <- unique(singleBirdStats2D$landAgeClass) #get classes that are represented in birdStats2D

#get all classes possible
landClasses <- rep(unique(birdDataNew$uniqueLandClass), times = maxAgeClass)
landClasses <- as.data.table(landClasses)
ageClassReps <- rep(1:maxAgeClass, times = length(unique(birdDataNew$uniquelandClass)))
ageClassReps <- as.data.table(ageClassReps)
allPossibleClasses <- cbind(landClasses, ageClassReps)
allPossibleClasses <-  unite(allPossibleClasses, allPossibleClasses, c(landClasses, ageClassReps), sep= ".", remove=FALSE) 

#get the classes not present in birdStats2D
classesNotPresent <- setdiff(allPossibleClasses$allPossibleClasses, landAgeClassesPresent)

##make list object of all stats outputs 
birdStatsList2D <- list(singleBirdStats2D, classesNotPresent)
names(birdStatsList2D) <- c("birdStats2D", "classesNotPresent")

return(birdStatsList2D)
   
    })

```


# References

Boreal Avian Modelling Project, 2020. BAM Generalized National Models Documentation, Version 4.0. Available at https://borealbirds.github.io/. DOI: 10.5281/zenodo.4018335. 
